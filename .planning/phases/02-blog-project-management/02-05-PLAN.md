---
phase: 02-blog-project-management
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api/blog-projects.ts
  - src/lib/auth.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can create a blog project with name and blog URL, sees success toast, project card appears on dashboard"
    - "Dashboard shows project card grid with stats after project creation"
    - "All write operations work even when user profile was not auto-created by signup trigger"
  artifacts:
    - path: "src/lib/auth.ts"
      provides: "ensureProfile() function that creates profile on-demand if missing"
      exports: ["ensureProfile"]
    - path: "src/lib/api/blog-projects.ts"
      provides: "createBlogProject using ensureProfile instead of raw .single() query"
  key_links:
    - from: "src/lib/api/blog-projects.ts"
      to: "src/lib/auth.ts"
      via: "ensureProfile() call in createBlogProject"
      pattern: "ensureProfile"
    - from: "src/lib/auth.ts"
      to: "profiles table"
      via: "upsert or insert-if-missing pattern"
      pattern: "profiles.*upsert|insert"
---

<objective>
Fix blog project creation failure caused by missing user profile row.

Purpose: createBlogProject() throws PGRST116 when querying profiles with .single() for users whose profile was never auto-created by the signup trigger (user existed before migration). This blocks ALL write operations (create, and transitively edit/delete since no projects exist). The fix adds on-demand profile creation so write operations self-heal the missing profile.

Output: Working createBlogProject that creates a profile on-demand when one doesn't exist, unblocking all Phase 2 CRUD operations.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/create-project-failure.md

@src/lib/auth.ts
@src/lib/api/blog-projects.ts
@supabase/migrations/00001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ensureProfile() to auth.ts and use it in createBlogProject</name>
  <files>src/lib/auth.ts, src/lib/api/blog-projects.ts</files>
  <action>
  **In src/lib/auth.ts**, add a new exported async function `ensureProfile(userId: string, email: string)` that:

  1. Queries profiles table for the user: `.from('profiles').select('tenant_id').eq('id', userId).single()`
  2. If profile exists (no error), returns `{ tenant_id: profile.tenant_id }`
  3. If profile does NOT exist (PGRST116 error or profileError), creates one on-demand:
     - Use `.from('profiles').insert({ id: userId, display_name: email.split('@')[0] || 'User' }).select('tenant_id').single()`
     - The `tenant_id` column has `DEFAULT gen_random_uuid()` so do NOT set it explicitly -- let the database generate it
     - Return `{ tenant_id: newProfile.tenant_id }`
  4. If the insert also fails (e.g., race condition where another request created it between the select and insert), retry the select once
  5. If all attempts fail, throw a descriptive error: `new Error('Unable to resolve user profile')`

  Important: Do NOT use Supabase `.upsert()` here because RLS on profiles only allows SELECT and UPDATE for authenticated users (no INSERT policy). The profile insert must go through the Supabase service role or use `.rpc()`. However, looking at the RLS policies, there is no INSERT policy on profiles at all -- the original trigger uses SECURITY DEFINER to bypass RLS. So the client-side insert will be blocked by RLS.

  **Alternative approach (simpler, works with existing RLS):** Instead of inserting from the client, use a Supabase RPC function. Create a new migration file `supabase/migrations/00003_ensure_profile.sql` that defines a SECURITY DEFINER function `ensure_profile_exists()`:

  ```sql
  CREATE OR REPLACE FUNCTION public.ensure_profile_exists()
  RETURNS TABLE(tenant_id UUID) AS $$
  DECLARE
    _tenant_id UUID;
  BEGIN
    -- Try to get existing profile
    SELECT p.tenant_id INTO _tenant_id
    FROM public.profiles p
    WHERE p.id = auth.uid();

    -- If found, return it
    IF FOUND THEN
      RETURN QUERY SELECT _tenant_id;
      RETURN;
    END IF;

    -- Profile missing, create it
    INSERT INTO public.profiles (id, display_name)
    VALUES (
      auth.uid(),
      COALESCE(
        (SELECT raw_user_meta_data->>'full_name' FROM auth.users WHERE id = auth.uid()),
        (SELECT raw_user_meta_data->>'name' FROM auth.users WHERE id = auth.uid()),
        split_part((SELECT email FROM auth.users WHERE id = auth.uid()), '@', 1)
      )
    )
    ON CONFLICT (id) DO NOTHING;

    -- Return the tenant_id (either just created or from race condition winner)
    SELECT p.tenant_id INTO _tenant_id
    FROM public.profiles p
    WHERE p.id = auth.uid();

    RETURN QUERY SELECT _tenant_id;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;
  ```

  Then in `src/lib/auth.ts`, add `ensureProfile()`:
  ```typescript
  export async function ensureProfile(): Promise<{ tenant_id: string }> {
    const { data, error } = await supabase.rpc('ensure_profile_exists')
    if (error) throw new Error(`Unable to resolve user profile: ${error.message}`)
    if (!data || data.length === 0) throw new Error('Unable to resolve user profile')
    return { tenant_id: data[0].tenant_id }
  }
  ```

  **In src/lib/api/blog-projects.ts**, replace lines 31-39 (the profile query with .single()) with a call to `ensureProfile()`:

  Replace:
  ```typescript
  // Get user's profile to retrieve tenant_id
  const { data: profile, error: profileError } = await supabase
    .from('profiles')
    .select('tenant_id')
    .eq('id', user.id)
    .single()

  if (profileError) throw profileError
  if (!profile) throw new Error('User profile not found')
  ```

  With:
  ```typescript
  // Ensure profile exists and get tenant_id (handles missing profile from pre-migration signups)
  const { tenant_id } = await ensureProfile()
  ```

  Add the import at the top of blog-projects.ts:
  ```typescript
  import { ensureProfile } from '@/lib/auth'
  ```

  **Also in src/lib/auth.ts**, update `getUser()` to use `ensureProfile()` instead of the fallback pattern. Replace lines 71-86 with:
  ```typescript
  // Ensure profile exists (creates on-demand if missing) and get data
  try {
    const { tenant_id } = await ensureProfile()
    const { data: profile } = await supabase
      .from('profiles')
      .select('display_name')
      .eq('id', authUser.id)
      .single()

    return {
      id: authUser.id,
      email: authUser.email,
      tenant_id,
      display_name: profile?.display_name || authUser.email.split('@')[0] || 'User',
    }
  } catch {
    // If ensureProfile fails entirely, fall back to empty tenant_id
    return {
      id: authUser.id,
      email: authUser.email,
      tenant_id: '',
      display_name: authUser.email.split('@')[0] || 'User',
    }
  }
  ```

  This way getUser() also benefits from on-demand profile creation rather than masking the issue with empty tenant_id.
  </action>
  <verify>
  1. Run `npx tsc --noEmit` -- must pass with no errors
  2. Run `npx vite build` -- must succeed
  3. Apply migration: `npx supabase db push` (or `supabase migration up` depending on local setup)
  4. Manual verification: Open the app, sign in, create a blog project with a name and URL -- should show success toast and project card on dashboard
  </verify>
  <done>
  - createBlogProject() successfully creates projects for users with or without existing profiles
  - Missing profiles are auto-created on first write operation via ensure_profile_exists() RPC
  - Success toast appears after project creation
  - Project card appears on dashboard after creation
  - TypeScript compiles cleanly
  - getUser() uses ensureProfile() instead of masking missing profiles with empty tenant_id
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npx vite build` succeeds
3. Migration 00003_ensure_profile.sql applied without errors
4. Blog project creation works end-to-end (UAT tests 2-6 should now pass)
</verification>

<success_criteria>
- Blog project creation succeeds for users whose profile was not auto-created by the signup trigger
- The ensure_profile_exists() RPC function creates profiles on-demand with SECURITY DEFINER (bypasses RLS)
- Race conditions handled via ON CONFLICT DO NOTHING + re-select pattern
- All existing functionality (dashboard loading, auth guard, project listing) continues to work
- UAT Test 2 ("Create a Blog Project") passes
- UAT Test 3 ("Dashboard Project Grid") passes (unblocked by Test 2 fix)
</success_criteria>

<output>
After completion, create `.planning/phases/02-blog-project-management/02-05-SUMMARY.md`
</output>
