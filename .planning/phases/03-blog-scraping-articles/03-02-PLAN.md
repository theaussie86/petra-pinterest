---
phase: 03-blog-scraping-articles
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/types/articles.ts
  - src/lib/api/articles.ts
  - src/lib/hooks/use-articles.ts
autonomous: true

must_haves:
  truths:
    - "Article types match the blog_articles database schema"
    - "API functions fetch, archive, restore, and trigger scrape for articles"
    - "TanStack Query hooks cache articles per project with proper invalidation"
    - "Scrape mutation calls the Edge Function and invalidates article cache on success"
  artifacts:
    - path: "src/types/articles.ts"
      provides: "Article TypeScript interface and related types"
      contains: "export interface Article"
    - path: "src/lib/api/articles.ts"
      provides: "Supabase CRUD operations for articles"
      contains: "getArticlesByProject"
    - path: "src/lib/hooks/use-articles.ts"
      provides: "TanStack Query hooks for articles"
      contains: "useArticles"
  key_links:
    - from: "src/lib/hooks/use-articles.ts"
      to: "src/lib/api/articles.ts"
      via: "import and queryFn/mutationFn"
      pattern: "import.*from.*api/articles"
    - from: "src/lib/api/articles.ts"
      to: "supabase"
      via: "Supabase client queries"
      pattern: "from.*blog_articles"
    - from: "src/lib/api/articles.ts"
      to: "supabase/functions/scrape-blog"
      via: "supabase.functions.invoke"
      pattern: "functions\\.invoke.*scrape-blog"
---

<objective>
Create the complete data layer for blog articles: TypeScript types, Supabase API functions, and TanStack Query hooks.

Purpose: Provides the typed data access layer that UI components will consume. Follows the exact same pattern established in Phase 2 for blog_projects (types -> API -> hooks).

Output: Three files providing type-safe article data access with caching, scrape triggering, and toast notifications.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-blog-scraping-articles/03-CONTEXT.md

# Follow the exact pattern from Phase 2:
@src/types/blog-projects.ts
@src/lib/api/blog-projects.ts
@src/lib/hooks/use-blog-projects.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create article types and API functions</name>
  <files>src/types/articles.ts, src/lib/api/articles.ts</files>
  <action>
**1. Create `src/types/articles.ts`:**

```typescript
export interface Article {
  id: string
  tenant_id: string
  blog_project_id: string
  title: string
  url: string
  content: string | null
  published_at: string | null
  scraped_at: string
  archived_at: string | null
  created_at: string
  updated_at: string
}

// For manual article addition (just a URL, content scraped automatically)
export interface ArticleInsert {
  blog_project_id: string
  url: string
}

// Scrape request payload sent to Edge Function
export interface ScrapeRequest {
  blog_project_id: string
  blog_url: string
  rss_url?: string | null
}

// Scrape response from Edge Function
export interface ScrapeResponse {
  success: boolean
  articles_found: number
  articles_created: number
  articles_updated: number
  method: 'rss' | 'html'
  errors: string[]
}

// Sort options for the articles table
export type ArticleSortField = 'title' | 'published_at' | 'scraped_at' | 'url'
export type SortDirection = 'asc' | 'desc'
```

**2. Create `src/lib/api/articles.ts`:**

Import supabase from `@/lib/supabase`, ensureProfile from `@/lib/auth`, and types from `@/types/articles`.

Functions to implement:

**getArticlesByProject(projectId: string): Promise<Article[]>**
- Select from blog_articles where blog_project_id = projectId AND archived_at IS NULL
- Order by published_at DESC NULLS LAST (newest first)
- Throw on error, return data

**getArticle(id: string): Promise<Article>**
- Select single article by id
- Throw on error, return data

**archiveArticle(id: string): Promise<Article>**
- Update archived_at = new Date().toISOString() where id matches
- Select and return updated article
- This is the "soft delete"

**restoreArticle(id: string): Promise<Article>**
- Update archived_at = null where id matches
- Select and return updated article

**getArchivedArticles(projectId: string): Promise<Article[]>**
- Select from blog_articles where blog_project_id = projectId AND archived_at IS NOT NULL
- Order by archived_at DESC

**scrapeBlog(request: ScrapeRequest): Promise<ScrapeResponse>**
- Call the Edge Function: `supabase.functions.invoke('scrape-blog', { body: request })`
- Parse the response data
- If error, throw with descriptive message
- Return typed ScrapeResponse

**addArticleManually(projectId: string, url: string): Promise<ScrapeResponse>**
- This is a special case of scraping: calls the Edge Function with a single URL
- The Edge Function should support a `single_url` parameter for this mode
- Actually, for simplicity, call `supabase.functions.invoke('scrape-blog', { body: { blog_project_id: projectId, single_url: url } })`
- Return ScrapeResponse (articles_found should be 0 or 1)

Note: Do NOT add ensureProfile() to read operations. Only write operations that might be the first action need it. For articles, the write is done server-side in the Edge Function, which handles auth via JWT.
  </action>
  <verify>
Both files exist. Run `npm run build` to verify TypeScript compilation passes with no errors. Check that imports resolve correctly.
  </verify>
  <done>
Article types interface matches database schema. API layer provides fetch, archive, restore, scrape trigger, and manual add functions. All functions use Supabase client with proper error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TanStack Query hooks for articles</name>
  <files>src/lib/hooks/use-articles.ts</files>
  <action>
Create `src/lib/hooks/use-articles.ts` following the exact pattern from `use-blog-projects.ts`.

**Hooks to implement:**

**useArticles(projectId: string)**
- useQuery with queryKey: ['articles', projectId]
- queryFn: () => getArticlesByProject(projectId)
- enabled: !!projectId
- staleTime: 30000 (match default)

**useArticle(id: string)**
- useQuery with queryKey: ['articles', 'detail', id]
- queryFn: () => getArticle(id)
- enabled: !!id

**useArchivedArticles(projectId: string)**
- useQuery with queryKey: ['articles', projectId, 'archived']
- queryFn: () => getArchivedArticles(projectId)
- enabled: !!projectId

**useScrapeBlog()**
- useMutation with mutationFn: scrapeBlog
- onSuccess: (data, variables) =>
  - toast.success(`Scrape complete: ${data.articles_found} found, ${data.articles_created} new, ${data.articles_updated} updated`)
  - Invalidate queries: ['articles', variables.blog_project_id]
- onError: () => toast.error('Failed to scrape blog. Check your blog URL and try again.')

**useArchiveArticle()**
- useMutation with mutationFn: archiveArticle
- onSuccess: () =>
  - toast.success('Article archived')
  - Invalidate queries: ['articles'] (broad invalidation to cover both active and archived lists)
- onError: () => toast.error('Failed to archive article')

**useRestoreArticle()**
- useMutation with mutationFn: restoreArticle
- onSuccess: () =>
  - toast.success('Article restored')
  - Invalidate queries: ['articles']
- onError: () => toast.error('Failed to restore article')

**useAddArticle()**
- useMutation wrapping addArticleManually
- mutationFn: ({ projectId, url }: { projectId: string; url: string }) => addArticleManually(projectId, url)
- onSuccess: (data, variables) =>
  - toast.success('Article added successfully')
  - Invalidate queries: ['articles', variables.projectId]
- onError: () => toast.error('Failed to add article. Check the URL and try again.')

Import all API functions from `@/lib/api/articles` and types from `@/types/articles`.
  </action>
  <verify>
File exists. Run `npm run build` to verify TypeScript compilation passes. All hooks should use correct queryKey patterns and import paths.
  </verify>
  <done>
TanStack Query hooks provide cached article queries per project, scrape mutation with progress feedback via toasts, archive/restore mutations with cache invalidation, and manual add mutation.
  </done>
</task>

</tasks>

<verification>
1. `src/types/articles.ts` exports Article, ArticleInsert, ScrapeRequest, ScrapeResponse types
2. `src/lib/api/articles.ts` exports getArticlesByProject, getArticle, archiveArticle, restoreArticle, scrapeBlog, addArticleManually
3. `src/lib/hooks/use-articles.ts` exports useArticles, useArticle, useArchivedArticles, useScrapeBlog, useArchiveArticle, useRestoreArticle, useAddArticle
4. `npm run build` passes with zero TypeScript errors
5. QueryKey patterns are consistent (['articles', projectId] for list, ['articles', 'detail', id] for detail)
</verification>

<success_criteria>
- All three files compile without errors
- Types match the blog_articles database schema exactly
- API functions cover all CRUD + scrape operations
- Hooks follow the established pattern from use-blog-projects.ts
- Cache invalidation correctly targets article queries by project ID
</success_criteria>

<output>
After completion, create `.planning/phases/03-blog-scraping-articles/03-02-SUMMARY.md`
</output>
