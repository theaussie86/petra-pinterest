---
phase: 07-data-migration
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - scripts/migration/migrate-pins.ts
autonomous: true

must_haves:
  truths:
    - "All Airtable Pins records are upserted into Supabase pins table"
    - "Pin status is correctly mapped from German Airtable values to English Supabase values"
    - "Pin images are downloaded from Airtable CDN and uploaded to Supabase Storage"
    - "Pin image_path follows existing convention: {tenant_id}/{pin_id}.ext"
    - "Pin title, description, and alt_text are correctly mapped"
    - "Pin scheduled_at is mapped from Airtable Veroffentlichungsdatum"
    - "Pin blog_article_id and board_id FKs correctly reference migrated entities"
    - "Broken image URLs are logged and skipped without stopping migration"
  artifacts:
    - path: "scripts/migration/migrate-pins.ts"
      provides: "Pin migration script with image upload"
      contains: "migrate-pins"
  key_links:
    - from: "scripts/migration/migrate-pins.ts"
      to: "scripts/migration/data/id-maps.json"
      via: "Article, board, and project ID mappings for FK references"
      pattern: "articleIdMap|boardIdMap|projectIdMap"
    - from: "scripts/migration/migrate-pins.ts"
      to: "scripts/migration/lib/helpers.ts"
      via: "downloadFile and uploadToStorage for pin images"
      pattern: "downloadFile|uploadToStorage"
    - from: "scripts/migration/migrate-pins.ts"
      to: "scripts/migration/lib/field-maps.ts"
      via: "PIN_STATUS_MAP for status conversion"
      pattern: "PIN_STATUS_MAP"
---

<objective>
Migrate pins from Airtable to Supabase, including downloading pin images from Airtable CDN and uploading to Supabase Storage.

Purpose: Pins are the core entity with the most complex field mapping (status conversion, image migration, multiple FK references). This is the largest and most critical migration script.

Output: CLI script that migrates pin records and their images.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-data-migration/07-CONTEXT.md
@.planning/phases/07-data-migration/07-01-SUMMARY.md
@.planning/phases/07-data-migration/07-02-SUMMARY.md
@.planning/phases/07-data-migration/07-03-SUMMARY.md
@supabase/migrations/00005_pins_and_boards.sql
@supabase/migrations/00007_english_pin_statuses.sql
@src/types/pins.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pin migration script with image upload</name>
  <files>scripts/migration/migrate-pins.ts</files>
  <action>
Create `scripts/migration/migrate-pins.ts` -- a CLI script run with `npx tsx scripts/migration/migrate-pins.ts`.

**Prerequisites:** `migrate-projects.ts`, `migrate-articles.ts`, and `migrate-boards.ts` must have run first.

**Algorithm:**

1. Load ID mappings from `scripts/migration/data/id-maps.json`
2. Verify all required mappings exist (projects, articles, boards)
3. Fetch all records from Airtable "Pins" table (`tblW9Qu3B4zzDtr8V`)
4. Get `MIGRATION_TENANT_ID` from env
5. For each Airtable pin record:
   a. **Map FK references:**
      - `blog_article_id`: fields["Blog Artikel"] is array of linked IDs -> look up in id-maps articles mapping
        - If no article mapping found, log error and skip this pin (article FK is NOT NULL)
      - `board_id`: fields["Board"] is array of linked IDs -> look up in id-maps boards mapping
        - If no board mapping found, set to NULL (board_id is nullable)
      - `blog_project_id`: Derive from the article's project. Look up the article in Supabase to get its blog_project_id, OR get from the Airtable pin's rollup field "Projekt Rollup (von Blog Artikel)". Simplest: query the already-migrated article's blog_project_id from Supabase.

   b. **Map pin data fields:**
      - `title` = fields["PIN Titel"] or null
      - `description` = fields["Beschreibung des Pins"] or null
      - `alt_text` = fields["Alt Text Bild"] or null
      - `status` = PIN_STATUS_MAP[fields["Status"]] (convert German -> English)
        - If status not in map, default to 'draft' and log warning
      - `error_message` = fields["Fehlerbeschreibung"] or null
      - `scheduled_at` = fields["Veroffentlichungsdatum"] (ISO datetime) or null
        - If pin status is 'published', also set `published_at` = `scheduled_at`
      - `pinterest_pin_id` = null (not stored in Airtable data)

   c. **Handle pin image:**
      - fields["Pin Bilder"] is an array of attachment objects
      - Take the FIRST attachment (pins have one image)
      - Each attachment has: `url`, `filename`, `type`, `width`, `height`
      - Generate pin UUID (or reuse from id-maps if re-running)
      - Download image from Airtable CDN URL using `downloadFile()`
      - Determine extension from filename (e.g., "10.png" -> ".png")
      - Upload to Supabase Storage: `pin-images` bucket, path `{tenant_id}/{pin_id}.{ext}`
      - Set `image_path` = `{tenant_id}/{pin_id}.{ext}`
      - If download or upload fails: log error, skip this pin, continue with others
      - Rate limit: add 200ms delay between image uploads to avoid overwhelming Storage API

   d. Set `tenant_id` = MIGRATION_TENANT_ID

6. **Upsert strategy:**
   - Generate deterministic UUIDs on first run, store in id-maps.json under "pins"
   - On re-run: reuse existing UUIDs, upsert by `id`
   - For image: check if image already exists in Storage before re-downloading (skip if exists and not re-uploading)
     - Use `supabaseAdmin.storage.from('pin-images').list(tenantId)` to check existing files
     - Only download + upload if file doesn't exist yet OR if `--force-images` CLI flag is passed

7. Save updated ID mapping file
8. Log results: total, created, updated, image_errors, skipped

**CLI flags:**
- `--force-images`: Re-download and re-upload all images even if they exist
- `--dry-run`: Log what would be done without making changes

**Data volume:** 100+ pins with images. At 200ms delay per image, this takes ~20 seconds total. Acceptable for the data volume.
  </action>
  <verify>
Run `npx tsx scripts/migration/migrate-pins.ts` and verify:
1. Console output shows "Pins: X created, Y updated, Z image errors, W skipped"
2. Check Supabase: `SELECT id, title, status, image_path, blog_article_id, board_id FROM pins LIMIT 5;` returns migrated pins
3. Verify status mapping: `SELECT status, COUNT(*) FROM pins GROUP BY status;` -- all statuses are valid English values
4. Verify images in Storage: `SELECT COUNT(*) FROM storage.objects WHERE bucket_id = 'pin-images';` -- matches pin count (minus image errors)
5. Verify scheduled pins: `SELECT id, title, scheduled_at FROM pins WHERE scheduled_at IS NOT NULL LIMIT 3;`
6. Run script again -- idempotent (0 created, X updated, images skipped)
7. id-maps.json updated with pin mappings
  </verify>
  <done>All pins migrated from Airtable to Supabase with correct status mapping, FK references, and images uploaded to Supabase Storage. Broken image URLs logged and skipped. Script is idempotent.</done>
</task>

</tasks>

<verification>
1. All Airtable Pins records exist in Supabase pins table
2. Pin statuses converted correctly (German -> English, removed statuses -> draft)
3. Pin images uploaded to Supabase Storage in {tenant_id}/{pin_id}.ext format
4. Pin blog_article_id correctly references migrated articles
5. Pin board_id correctly references migrated boards (or null)
6. Pin blog_project_id derived from article's project
7. Pin title, description, alt_text mapped correctly
8. Pin scheduled_at/published_at set for published pins
9. Image errors logged without stopping migration
10. Script is idempotent with image skip optimization
</verification>

<success_criteria>
All pins (100+) migrated to Supabase with correct status mapping, FK references, and images in Storage. Broken image URLs are logged for manual review. Re-running the script skips existing images and updates existing records.
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-migration/07-04-SUMMARY.md`
</output>
