---
phase: 07-data-migration
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - scripts/migration/migrate-projects.ts
  - scripts/migration/migrate-articles.ts
autonomous: true

must_haves:
  truths:
    - "All Airtable Blog Projekte records are upserted into Supabase blog_projects with all branding fields"
    - "All Airtable Blog Artikel records are upserted into Supabase blog_articles with correct status mapping"
    - "Airtable record IDs are stored for cross-reference in later pin/board migration"
    - "Scripts are idempotent -- re-running updates existing records without duplicates"
    - "Article statuses are mapped from German Airtable values to Supabase equivalents"
  artifacts:
    - path: "scripts/migration/migrate-projects.ts"
      provides: "Blog project migration script"
      contains: "migrate-projects"
    - path: "scripts/migration/migrate-articles.ts"
      provides: "Blog article migration script"
      contains: "migrate-articles"
  key_links:
    - from: "scripts/migration/migrate-projects.ts"
      to: "scripts/migration/lib/field-maps.ts"
      via: "PROJECT_BRANDING_MAP for field mapping"
      pattern: "PROJECT_BRANDING_MAP"
    - from: "scripts/migration/migrate-articles.ts"
      to: "scripts/migration/migrate-projects.ts"
      via: "Needs project ID mapping (Airtable -> Supabase) to set blog_project_id FK"
      pattern: "projectIdMap"
---

<objective>
Migrate blog projects and articles from Airtable to Supabase.

Purpose: Projects must be migrated first (articles reference them via FK). Both scripts use upsert logic for idempotent re-runs during the transition period.

Output: Two CLI scripts that read from Airtable API and upsert into Supabase.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-data-migration/07-CONTEXT.md
@.planning/phases/07-data-migration/07-01-SUMMARY.md
@supabase/migrations/00002_blog_projects.sql
@supabase/migrations/00004_blog_articles.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create blog project migration script</name>
  <files>scripts/migration/migrate-projects.ts</files>
  <action>
Create `scripts/migration/migrate-projects.ts` -- a CLI script run with `npx tsx scripts/migration/migrate-projects.ts`.

**Algorithm:**

1. Fetch all records from Airtable "Blog Projekte" table (`tblZkW6ektjSmNOMG`)
2. Get `MIGRATION_TENANT_ID` from env
3. For each Airtable record:
   a. Map core fields:
      - `name` = fields["Name"]
      - `blog_url` = fields["Blog URL"]
      - `description` = fields["Beschreibung des Blogs"]
   b. Map branding fields using `PROJECT_BRANDING_MAP` from field-maps.ts:
      - For each key in PROJECT_BRANDING_MAP, check if Airtable field exists, map to Supabase column
      - Special handling for "Stil Optionen" (multipleSelects): join array with ", " into single string
      - Special handling for "Sprache" (singleSelect): extract string value directly
   c. Set `tenant_id` = MIGRATION_TENANT_ID
   d. Generate a deterministic ID using the Airtable record ID (or use a mapping file)

4. **Upsert strategy**: Use Supabase's `.upsert()` with `onConflict: 'id'`. But since we need to map Airtable IDs to Supabase UUIDs consistently across re-runs:
   - Create a mapping JSON file `scripts/migration/data/id-maps.json` that persists Airtable-to-Supabase ID mappings
   - On first run: generate new UUIDs, store in mapping file
   - On subsequent runs: reuse existing UUIDs from mapping file
   - Format: `{ "projects": { "recXXX": "uuid-xxx", ... }, "articles": { ... }, ... }`

5. Upsert each project record into Supabase
6. Save the ID mapping file
7. Log results using `logMigrationResult()`

**ID mapping file structure (`scripts/migration/data/id-maps.json`):**
```typescript
interface IdMaps {
  projects: Record<string, string>   // airtableId -> supabaseUUID
  articles: Record<string, string>
  boards: Record<string, string>
  pins: Record<string, string>
}
```

Create the `scripts/migration/data/` directory. Add `scripts/migration/data/` to `.gitignore`.

**Formula fields (Domain, Hook Prompt Kontext Part) -- SKIP.** Per decisions: no denormalized/cached fields, rollups and formulas become JOINs at query time. These formula fields are computed and not stored.
  </action>
  <verify>
Run `npx tsx scripts/migration/migrate-projects.ts` and verify:
1. Console output shows "Projects: X created, Y updated, Z errors"
2. Check Supabase: `SELECT id, name, blog_url, target_audience, brand_voice FROM blog_projects;` returns migrated projects with branding fields populated
3. Run script again -- output shows "0 created, X updated" (idempotent)
4. `scripts/migration/data/id-maps.json` exists with project mappings
  </verify>
  <done>Blog projects migrated from Airtable to Supabase with all branding fields. ID mappings persisted for cross-reference. Script is idempotent.</done>
</task>

<task type="auto">
  <name>Task 2: Create blog article migration script</name>
  <files>scripts/migration/migrate-articles.ts</files>
  <action>
Create `scripts/migration/migrate-articles.ts` -- a CLI script run with `npx tsx scripts/migration/migrate-articles.ts`.

**Prerequisites:** `migrate-projects.ts` must have run first (needs project ID mappings).

**Algorithm:**

1. Load ID mappings from `scripts/migration/data/id-maps.json`
2. Fetch all records from Airtable "Blog Artikel" table (`tblBNlgON5h27AHfn`)
3. Get `MIGRATION_TENANT_ID` from env
4. For each Airtable record:
   a. Map fields:
      - `title` = fields["Name"]
      - `url` = fields["Post URL"]
      - `content` = fields["Content"] (full HTML content, nullable)
      - `published_at` = fields["Artikel Anderungsdatum"] (ISO datetime string, nullable)
      - `scraped_at` = fields["Created"] or NOW() if not available
      - `archived_at` = NULL for all statuses except handle Fehler specially
   b. Map `blog_project_id`:
      - fields["Projekt"] is an array of linked record IDs (e.g., ["rec4whLeKUCBPNBO2"])
      - Look up in id-maps.json projects mapping to get Supabase UUID
      - If no project mapping found, log error and skip
   c. Handle article status:
      - Airtable statuses: "Blogartikel abrufen", "Neu", "Content gescannt", "Fehler"
      - Supabase blog_articles has no explicit status column -- uses `archived_at` for active/archived
      - All statuses map to active (archived_at = NULL)
      - For "Fehler" status: store the Fehlerbeschreibung somewhere? The blog_articles table doesn't have an error field. Since no schema change is warranted for a migration-only concern, log the error status to the migration report and set archived_at = NULL (keep active).
   d. Set `tenant_id` = MIGRATION_TENANT_ID

5. **Upsert strategy**: Use the unique constraint on `(blog_project_id, url)` for conflict resolution. This matches the existing schema design.
   - Use Supabase `.upsert()` with `onConflict: 'blog_project_id,url'`
   - After upsert, read back the inserted/updated record to get its UUID
   - Store Airtable-to-Supabase ID mapping in id-maps.json under "articles"

6. Save updated ID mapping file
7. Log results

**Important:** Article content can be very long. No truncation -- store full content as-is.
  </action>
  <verify>
Run `npx tsx scripts/migration/migrate-articles.ts` and verify:
1. Console output shows "Articles: X created, Y updated, Z errors"
2. Check Supabase: `SELECT id, title, url, blog_project_id FROM blog_articles LIMIT 5;` returns migrated articles
3. Verify article content is not truncated: `SELECT id, LENGTH(content) FROM blog_articles WHERE content IS NOT NULL LIMIT 3;`
4. Run script again -- idempotent (0 created, X updated)
5. id-maps.json updated with article mappings
  </verify>
  <done>Blog articles migrated from Airtable to Supabase with full content. All articles linked to correct blog projects via FK. ID mappings persisted for pin migration.</done>
</task>

</tasks>

<verification>
1. All Airtable Blog Projekte records exist in Supabase blog_projects
2. All branding fields (target_audience, brand_voice, etc.) are populated
3. All Airtable Blog Artikel records exist in Supabase blog_articles
4. Article blog_project_id FK correctly references migrated projects
5. Article content is complete (not truncated)
6. ID mapping file contains both project and article mappings
7. Both scripts are idempotent (re-run produces 0 creates)
8. Airtable article statuses are handled without data loss
</verification>

<success_criteria>
All blog projects (2) and articles (~99) are migrated to Supabase with correct field mappings and foreign key relationships. Re-running either script updates existing records without creating duplicates. ID mapping file enables cross-referencing for subsequent pin/board migration.
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-migration/07-02-SUMMARY.md`
</output>
