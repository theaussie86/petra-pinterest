---
phase: 07-data-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00008_blog_project_branding_fields.sql
  - scripts/migration/lib/airtable-client.ts
  - scripts/migration/lib/supabase-admin.ts
  - scripts/migration/lib/helpers.ts
  - scripts/migration/lib/field-maps.ts
  - .env.example
autonomous: true

must_haves:
  truths:
    - "blog_projects table has individual columns for all 16+ AI/branding fields from Airtable"
    - "board-covers and brand-kit storage buckets exist in Supabase with public read access"
    - "Airtable client utility reads records with pagination and rate limiting"
    - "Supabase admin client bypasses RLS using service role key"
    - "Field mapping constants map Airtable field names to Supabase column names"
  artifacts:
    - path: "supabase/migrations/00008_blog_project_branding_fields.sql"
      provides: "Schema additions for AI/branding fields and storage buckets"
      contains: "target_audience"
    - path: "scripts/migration/lib/airtable-client.ts"
      provides: "Airtable API client with pagination"
      exports: ["fetchAllRecords"]
    - path: "scripts/migration/lib/supabase-admin.ts"
      provides: "Supabase admin client for migration scripts"
      exports: ["supabaseAdmin"]
    - path: "scripts/migration/lib/helpers.ts"
      provides: "Shared migration helpers"
      exports: ["downloadFile", "uploadToStorage", "logMigrationResult"]
    - path: "scripts/migration/lib/field-maps.ts"
      provides: "Field mapping constants for all entity types"
      exports: ["ARTICLE_STATUS_MAP", "PIN_STATUS_MAP"]
  key_links:
    - from: "scripts/migration/lib/airtable-client.ts"
      to: "AIRTABLE_PAT env var"
      via: "process.env.AIRTABLE_PAT"
      pattern: "process\\.env\\.AIRTABLE_PAT"
    - from: "scripts/migration/lib/supabase-admin.ts"
      to: "SUPABASE_SECRET_KEY env var"
      via: "createClient with service role key"
      pattern: "SUPABASE_SECRET_KEY"
---

<objective>
Create the database schema additions and shared migration utilities needed by all entity migration scripts.

Purpose: Foundation layer -- blog_projects needs 16+ new columns for AI/branding fields, new storage buckets are needed for board covers and brand kit files, and all migration scripts share common utilities (Airtable client, Supabase admin client, field mappings, file download/upload helpers).

Output: Migration SQL applied, shared utility modules in scripts/migration/lib/, env vars documented.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-data-migration/07-CONTEXT.md
@supabase/migrations/00002_blog_projects.sql
@supabase/migrations/00005_pins_and_boards.sql
@supabase/migrations/00007_english_pin_statuses.sql
@src/types/blog-projects.ts
@src/types/pins.ts
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration for blog_projects branding fields and storage buckets</name>
  <files>supabase/migrations/00008_blog_project_branding_fields.sql</files>
  <action>
Create migration `00008_blog_project_branding_fields.sql` that adds individual columns to `blog_projects` for all Airtable AI/branding fields (per user decision: individual columns, NOT JSONB).

**New columns on blog_projects (all TEXT, nullable):**
- `target_audience` (from Airtable "Zielgruppe")
- `brand_voice` (from "Tonalitat / Markenstimme")
- `visual_style` (from "Visueller Stil / Bildsprache")
- `general_keywords` (from "Allgemeine Keywords / Nische")
- `language` (from "Sprache")
- `value_proposition` (from "Wertversprechen")
- `style_options` (from "Stil Optionen" -- stored as comma-separated text)
- `content_type` (from "Content Typ")
- `main_motifs` (from "Hauptmotive Beispiele")
- `color_palette` (from "Farbpalette Beschreibung")
- `text_instructions` (from "Spezielle Text Anweisungen")
- `blog_niche` (from "Blog Nische")
- `additional_instructions` (from "Zusatzliche Anweisungen")
- `topic_context` (from "Themen Kontext")
- `visual_audience` (from "Visuelle Zielgruppe")
- `lighting_description` (from "Licht Beschreibung")

Use `ALTER TABLE public.blog_projects ADD COLUMN IF NOT EXISTS` for each column.

**Storage buckets:**

Create two new storage buckets:
```sql
INSERT INTO storage.buckets (id, name, public)
VALUES ('board-covers', 'board-covers', true)
ON CONFLICT (id) DO NOTHING;

INSERT INTO storage.buckets (id, name, public)
VALUES ('brand-kit', 'brand-kit', true)
ON CONFLICT (id) DO NOTHING;
```

Add RLS policies for both buckets following the same pattern as pin-images:
- Public SELECT for reads
- Authenticated INSERT/UPDATE/DELETE with tenant folder isolation using `storage.foldername(name)[1]`

Apply via Supabase MCP `apply_migration`.
  </action>
  <verify>
Run via Supabase MCP: `SELECT column_name FROM information_schema.columns WHERE table_name = 'blog_projects' AND column_name IN ('target_audience', 'brand_voice', 'visual_style', 'blog_niche') ORDER BY column_name;` -- returns all 4 columns.

Also verify buckets: `SELECT id FROM storage.buckets WHERE id IN ('board-covers', 'brand-kit');` -- returns both.
  </verify>
  <done>blog_projects table has 16 new branding columns. board-covers and brand-kit storage buckets exist with RLS policies.</done>
</task>

<task type="auto">
  <name>Task 2: Create shared migration utilities</name>
  <files>scripts/migration/lib/airtable-client.ts, scripts/migration/lib/supabase-admin.ts, scripts/migration/lib/helpers.ts, scripts/migration/lib/field-maps.ts, .env.example</files>
  <action>
Create `scripts/migration/lib/` directory with four shared modules. These are disposable CLI scripts run with `tsx`.

**1. `scripts/migration/lib/airtable-client.ts`:**

```typescript
const AIRTABLE_PAT = process.env.AIRTABLE_PAT
const BASE_ID = 'appWR3q78rre27F5q'
const API_URL = `https://api.airtable.com/v0/${BASE_ID}`

interface AirtableRecord {
  id: string
  fields: Record<string, any>
  createdTime: string
}

interface AirtableResponse {
  records: AirtableRecord[]
  offset?: string
}

export async function fetchAllRecords(tableId: string): Promise<AirtableRecord[]> {
  // Paginate through all records using offset
  // Rate limit: 100ms delay between requests (Airtable allows 5 req/sec)
  // Return all records concatenated
}

export { type AirtableRecord }
```

Table IDs as constants:
- `TABLES.BLOG_PROJEKTE = 'tblZkW6ektjSmNOMG'`
- `TABLES.BLOG_ARTIKEL = 'tblBNlgON5h27AHfn'`
- `TABLES.PINS = 'tblW9Qu3B4zzDtr8V'`
- `TABLES.BOARDS = 'tblhrv8QYrWYrFpis'`

**2. `scripts/migration/lib/supabase-admin.ts`:**

```typescript
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.SUPABASE_URL!
const supabaseKey = process.env.SUPABASE_SECRET_KEY!

export const supabaseAdmin = createClient(supabaseUrl, supabaseKey)
```

Service role key bypasses RLS -- required for migration scripts that write data for a specific tenant.

**3. `scripts/migration/lib/helpers.ts`:**

Export helpers:
- `downloadFile(url: string): Promise<Buffer>` -- Downloads a file from URL (Airtable CDN), returns Buffer. Handles errors gracefully (logs and returns null on failure).
- `uploadToStorage(bucket: string, path: string, buffer: Buffer, contentType: string): Promise<string | null>` -- Uploads to Supabase Storage using admin client, returns public URL or null on error. Uses upsert mode.
- `logMigrationResult(entity: string, stats: { created: number, updated: number, skipped: number, errors: string[] }): void` -- Console log with summary and error details.
- `sleep(ms: number): Promise<void>` -- Simple delay for rate limiting.
- `getFileExtension(filename: string): string` -- Extract extension from filename.
- `getTenantId(): string` -- Returns the hardcoded tenant_id for Petra's account (read from env var `MIGRATION_TENANT_ID`).

**4. `scripts/migration/lib/field-maps.ts`:**

Export field mapping constants:

```typescript
// Article status mapping: Airtable German -> Supabase
export const ARTICLE_STATUS_MAP: Record<string, string | null> = {
  'Content gescannt': null,     // active (no archived_at)
  'Blogartikel abrufen': null,  // active (in-progress scrape state)
  'Neu': null,                  // active (newly discovered)
  'Fehler': null,               // active but with error (store error in separate handling)
}

// Pin status mapping: Airtable German -> Supabase English
export const PIN_STATUS_MAP: Record<string, string> = {
  'Entwurf': 'draft',
  'Bereit fur Generierung': 'ready_for_generation',  // note: without umlaut in Airtable select
  'Bereit für Generierung': 'ready_for_generation',
  'Pin generieren': 'draft',            // removed status, fallback to draft
  'Pin wird generiert': 'draft',        // removed status, fallback to draft
  'Pin generiert': 'draft',             // removed status, fallback to draft
  'Metadaten generieren': 'generate_metadata',
  'Metadaten werden generiert': 'generating_metadata',
  'Metadaten erstellt': 'metadata_created',
  'Bereit zum Planen/Veröffentlichen': 'ready_to_schedule',
  'Veröffentlicht': 'published',
  'Fehler': 'error',
  'Löschen': 'deleted',
  'Loschen': 'deleted',  // variant without umlaut
}

// Blog project branding field mapping: Airtable field name -> Supabase column
export const PROJECT_BRANDING_MAP: Record<string, string> = {
  'Zielgruppe': 'target_audience',
  'Tonalitat / Markenstimme': 'brand_voice',
  'Tonalität / Markenstimme': 'brand_voice',
  'Visueller Stil / Bildsprache': 'visual_style',
  'Allgemeine Keywords / Nische': 'general_keywords',
  'Sprache': 'language',
  'Wertversprechen': 'value_proposition',
  'Stil Optionen': 'style_options',
  'Content Typ': 'content_type',
  'Hauptmotive Beispiele': 'main_motifs',
  'Farbpalette Beschreibung': 'color_palette',
  'Spezielle Text Anweisungen': 'text_instructions',
  'Blog Nische': 'blog_niche',
  'Zusatzliche Anweisungen': 'additional_instructions',
  'Zusätzliche Anweisungen': 'additional_instructions',
  'Themen Kontext': 'topic_context',
  'Visuelle Zielgruppe': 'visual_audience',
  'Licht Beschreibung': 'lighting_description',
}
```

**5. Update `.env.example`:**

Add under a new `# Migration Configuration` section:
```
AIRTABLE_PAT=your-airtable-personal-access-token
MIGRATION_TENANT_ID=your-tenant-uuid
```

Note: AIRTABLE_PAT likely already exists in ~/.zshrc but document in .env.example for completeness.
  </action>
  <verify>
Run `npx tsx scripts/migration/lib/airtable-client.ts` -- should not error (module only exports, no main). Check that all 4 files exist with proper exports. Verify .env.example has new section.
  </verify>
  <done>Shared migration utilities exist: Airtable client with pagination, Supabase admin client, file helpers, and complete field mapping constants. Env vars documented.</done>
</task>

</tasks>

<verification>
1. blog_projects table has all 16 new branding columns
2. board-covers and brand-kit storage buckets exist with RLS policies
3. Airtable client module exports fetchAllRecords with pagination
4. Supabase admin client creates client with service role key
5. Field maps cover all Airtable statuses and branding fields
6. Helpers include download, upload, logging, and tenant ID functions
7. .env.example documents AIRTABLE_PAT and MIGRATION_TENANT_ID
</verification>

<success_criteria>
Schema migration applied successfully. All shared utilities compile without TypeScript errors. Field mapping constants cover every Airtable status and branding field observed in the live data.
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-migration/07-01-SUMMARY.md`
</output>
