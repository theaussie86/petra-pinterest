---
phase: 01-foundation-security
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/auth.ts
  - src/routes/_authed.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "After signing in with Google, user lands on /dashboard (not redirected back to /login)"
    - "Auth guard distinguishes 'not authenticated' from 'authenticated but no profile yet'"
    - "User context still provides display_name and tenant_id when profile exists"
    - "First-time signups with delayed profile trigger still reach dashboard"
  artifacts:
    - path: "src/lib/auth.ts"
      provides: "Separated auth check and profile fetch functions"
      contains: "getAuthUser"
    - path: "src/routes/_authed.tsx"
      provides: "Auth guard that checks authentication only"
      contains: "getAuthUser"
  key_links:
    - from: "src/routes/_authed.tsx"
      to: "src/lib/auth.ts"
      via: "getAuthUser import for auth-only check"
      pattern: "getAuthUser"
    - from: "src/routes/_authed.tsx"
      to: "src/lib/auth.ts"
      via: "getUser import for profile-enriched data"
      pattern: "getUser"
---

<objective>
Fix the auth guard redirect loop that prevents authenticated users from reaching /dashboard after Google OAuth sign-in.

Purpose: UAT Test 3 failed -- after successful Google OAuth, users see the success toast but are immediately redirected back to /login. The root cause is that `getUser()` conflates authentication status with profile existence: it returns null when the profiles row doesn't exist yet (race condition with database trigger on first signup), and the auth guard treats any null as "not authenticated."

Output: A working auth flow where the guard checks authentication only (via `supabase.auth.getUser()`), and profile data is fetched separately with graceful fallback for first-time signups whose profile trigger hasn't completed yet.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-security/01-04-SUMMARY.md
@.planning/phases/01-foundation-security/01-UAT.md
@.planning/debug/auth-guard-rejects-session.md
@src/lib/auth.ts
@src/routes/_authed.tsx
@src/routes/_authed/dashboard.tsx
@src/components/layout/header.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Separate auth check from profile fetch in auth.ts</name>
  <files>src/lib/auth.ts</files>
  <action>
Refactor `src/lib/auth.ts` to separate authentication verification from profile data fetching:

1. **Keep the existing `AuthUser` interface** unchanged (id, email, tenant_id, display_name).

2. **Add a new `getAuthUser()` function** that ONLY checks Supabase authentication:
   - Calls `supabase.auth.getUser()` (network-verified, not just session)
   - Returns `{ id, email }` if authenticated, `null` if not
   - Does NOT touch the profiles table at all
   - This is the function the auth guard will use

3. **Refactor existing `getUser()` function** to build on `getAuthUser()`:
   - First calls `getAuthUser()` -- if null, return null (not authenticated)
   - Then queries profiles table for tenant_id and display_name
   - If profile query fails or returns no row: return a PARTIAL user object with fallback values instead of null. Use `{ id, email, tenant_id: '', display_name: email.split('@')[0] || 'User' }` as fallback
   - If profile query succeeds: return full AuthUser as before
   - This means `getUser()` NEVER returns null for an authenticated user -- only for truly unauthenticated requests

4. **Do NOT change** `signInWithGoogle()`, `signOut()`, or `onAuthStateChange()` -- they are working correctly.

Why this approach: The auth guard needs a fast, reliable "is this user authenticated?" check that cannot be confused by profile row timing. The profile enrichment is a separate concern. By making `getUser()` return fallback data when the profile doesn't exist yet, downstream consumers (dashboard, header) still get a usable object and can display gracefully.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- must compile with zero errors. Verify that auth.ts exports both `getAuthUser` and `getUser`. Verify `getAuthUser` does not reference the profiles table. Verify `getUser` returns fallback values (not null) when profile query fails.
  </verify>
  <done>
auth.ts exports `getAuthUser()` (auth-only check returning {id, email} | null) and refactored `getUser()` (returns AuthUser with fallback display values when profile missing, only returns null when truly unauthenticated). TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update auth guard to use auth-only check</name>
  <files>src/routes/_authed.tsx</files>
  <action>
Update `src/routes/_authed.tsx` to use the new separated auth functions:

1. **Change the beforeLoad guard** to use a two-step approach:
   - First: call `getAuthUser()` to check if the user is authenticated. If null, redirect to /login. This is the GATE -- fast, reliable, no profile dependency.
   - Second: call `getUser()` to get the full profile-enriched user data. Since `getUser()` now returns fallback values for missing profiles (never null for authenticated users), this will always succeed for authenticated users.
   - Return `{ user }` to route context as before.

2. **Import both** `getAuthUser` and `getUser` from `@/lib/auth`.

3. **Do NOT change** the component (Outlet render) or the route path.

Why two calls: The guard's PRIMARY job is access control (are you authenticated?). The SECONDARY job is providing user context to child routes. Separating these ensures that a missing profile row never triggers a login redirect. The second call (`getUser()`) enriches context for the dashboard/header but cannot cause a redirect.

Note: This means the auth guard makes 2 Supabase calls (one auth check + one profile query). This is acceptable because:
- The auth check is fast (JWT verification)
- The profile query is a single-row indexed lookup
- Correctness matters more than one extra query
- A future optimization could combine them, but NOT at the cost of the redirect bug
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- must compile with zero errors. Read the updated _authed.tsx and confirm: (1) it imports getAuthUser, (2) beforeLoad first checks getAuthUser() and redirects if null, (3) then calls getUser() for context data, (4) returns { user } to children.
  </verify>
  <done>
Auth guard uses getAuthUser() for the authentication gate (redirect decision) and getUser() for profile context (never null for authenticated users). An authenticated user with no profile row reaches /dashboard with fallback display values instead of being redirected to /login.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `npx tsc --noEmit` passes with zero errors
2. `src/lib/auth.ts` exports: signInWithGoogle, signOut, getUser, getAuthUser, onAuthStateChange
3. `getAuthUser()` only calls `supabase.auth.getUser()` -- no profiles table access
4. `getUser()` returns fallback AuthUser (not null) when profile query fails for authenticated user
5. `_authed.tsx` uses `getAuthUser()` for the redirect gate, `getUser()` for context enrichment
6. No changes to login.tsx, auth.callback.tsx, dashboard.tsx, or header.tsx needed
</verification>

<success_criteria>
- An authenticated user whose profile row does not yet exist (first-time signup, trigger delay) is NOT redirected to /login
- The auth guard correctly redirects truly unauthenticated users (no session) to /login
- Dashboard and header receive user context with at minimum {id, email, tenant_id: '', display_name: derived-from-email}
- TypeScript compiles cleanly with no errors
- UAT Test 3 scenario ("sign in -> toast success -> lands on /dashboard") works
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-05-SUMMARY.md`
</output>
