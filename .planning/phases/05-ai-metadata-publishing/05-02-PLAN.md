---
phase: 05-ai-metadata-publishing
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/server/metadata.ts
  - server/inngest/functions/generate-metadata.ts
  - server/inngest/index.ts
  - src/lib/api/metadata.ts
  - src/lib/hooks/use-metadata.ts
autonomous: true

must_haves:
  truths:
    - "Single pin metadata generation works via server function with cookie auth"
    - "Bulk pin metadata generation works via Inngest pipeline"
    - "Regeneration with feedback passes feedback to OpenAI"
    - "Generation history is stored and queryable per pin"
    - "Status auto-advances to metadaten_erstellt after successful generation"
  artifacts:
    - path: "src/lib/server/metadata.ts"
      provides: "Server functions for metadata generation"
      exports: ["generateMetadataFn", "generateMetadataWithFeedbackFn", "triggerBulkMetadataFn"]
    - path: "server/inngest/functions/generate-metadata.ts"
      provides: "Inngest bulk metadata pipeline"
      exports: ["generateMetadataBulk"]
    - path: "src/lib/api/metadata.ts"
      provides: "Client API for metadata operations"
      exports: ["getMetadataHistory", "restoreMetadataGeneration"]
    - path: "src/lib/hooks/use-metadata.ts"
      provides: "TanStack Query hooks for metadata"
      exports: ["useMetadataHistory", "useGenerateMetadata", "useGenerateMetadataWithFeedback", "useTriggerBulkMetadata", "useRestoreMetadataGeneration"]
  key_links:
    - from: "src/lib/server/metadata.ts"
      to: "src/lib/openai/client.ts"
      via: "import generatePinMetadata"
      pattern: "generatePinMetadata"
    - from: "server/inngest/functions/generate-metadata.ts"
      to: "src/lib/openai/client.ts"
      via: "import generatePinMetadata"
      pattern: "generatePinMetadata"
    - from: "src/lib/hooks/use-metadata.ts"
      to: "src/lib/server/metadata.ts"
      via: "server function calls"
      pattern: "generateMetadataFn|triggerBulkMetadataFn"
---

<objective>
Build the server-side metadata generation pipeline (single + bulk) and client-side data layer (API functions, TanStack Query hooks).

Purpose: Complete backend for AI metadata generation — server functions call OpenAI, Inngest handles bulk, hooks expose to UI.
Output: Server functions, Inngest function, API layer, TanStack Query hooks for metadata operations.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-metadata-publishing/05-CONTEXT.md
@.planning/phases/05-ai-metadata-publishing/05-RESEARCH.md
@.planning/phases/05-ai-metadata-publishing/05-01-SUMMARY.md
@src/lib/server/scraping.ts
@src/lib/server/supabase.ts
@server/inngest/functions/scrape-blog.ts
@server/inngest/index.ts
@src/lib/api/pins.ts
@src/lib/hooks/use-pins.ts
@src/types/pins.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server functions and Inngest pipeline for metadata generation</name>
  <files>
    src/lib/server/metadata.ts
    server/inngest/functions/generate-metadata.ts
    server/inngest/index.ts
  </files>
  <action>
1. Create `src/lib/server/metadata.ts` with three server functions following the existing pattern in `src/lib/server/scraping.ts`:

   a) `generateMetadataFn` — Single pin, synchronous:
      - createServerFn({ method: 'POST' })
      - Input: `{ pin_id: string }`
      - Authenticate via `getSupabaseServerClient()` -> `supabase.auth.getUser()` -> get tenant_id from profiles
      - Update pin status to 'metadaten_werden_generiert' first
      - Fetch pin with article data: `supabase.from('pins').select('*, blog_articles(title, content)').eq('id', pin_id).single()`
      - Get pin image URL via `getPinImageUrl(pin.image_path)` — import from `@/lib/api/pins`
      - Call `generatePinMetadata(article.title, article.content, imageUrl)` from `@/lib/openai/client`
      - Insert into `pin_metadata_generations` table (pin_id, tenant_id, title, description, alt_text, feedback: null)
      - Update pin: set title, description, alt_text, status to 'metadaten_erstellt'
      - Prune old generations: DELETE from pin_metadata_generations WHERE pin_id = X AND id NOT IN (SELECT id ORDER BY created_at DESC LIMIT 3)
      - On error: update pin status to 'fehler', set error_message to error string
      - Return `{ success: true, metadata: { title, description, alt_text } }`

   b) `generateMetadataWithFeedbackFn` — Single pin with feedback, synchronous:
      - createServerFn({ method: 'POST' })
      - Input: `{ pin_id: string; feedback: string }`
      - Same auth pattern as above
      - Fetch previous generation from `pin_metadata_generations` (latest for pin_id)
      - Fetch pin + article data
      - Build conversation messages array (see RESEARCH.md Pattern: "Metadata Generation with Feedback Refinement"):
        - system: PINTEREST_SEO_SYSTEM_PROMPT
        - user: article content + pin image (multimodal)
        - assistant: previous generation JSON
        - user: "Please regenerate the metadata with this feedback: {feedback}"
      - Call OpenAI directly (not via generatePinMetadata helper) since conversation messages are custom
      - Store new generation in pin_metadata_generations WITH feedback text
      - Update pin with new values, set status to 'metadaten_erstellt'
      - Prune old generations (keep last 3)
      - Return `{ success: true, metadata }`

   c) `triggerBulkMetadataFn` — Bulk, async via Inngest:
      - createServerFn({ method: 'POST' })
      - Input: `{ pin_ids: string[] }`
      - Authenticate, get tenant_id
      - Update all selected pins status to 'metadaten_werden_generiert'
      - Send Inngest event: `inngest.send({ name: 'pin/metadata.bulk-requested', data: { pin_ids, tenant_id } })`
      - Return `{ success: true, pins_queued: pin_ids.length }`

2. Create `server/inngest/functions/generate-metadata.ts`:
   - Follow the exact pattern from `server/inngest/functions/scrape-blog.ts`
   - `generateMetadataBulk = inngest.createFunction({ id: 'generate-metadata-bulk' }, { event: 'pin/metadata.bulk-requested' }, ...)`
   - Process each pin_id sequentially in `step.run(`generate-metadata-${pin_id}`, ...)`:
     - Create Supabase service client
     - Fetch pin + article: `supabase.from('pins').select('*, blog_articles(title, content)').eq('id', pin_id).single()`
     - Get pin image URL using Supabase storage public URL pattern (construct manually since this is server-side, not client): `${process.env.SUPABASE_URL}/storage/v1/object/public/pin-images/${pin.image_path}`
     - Call `generatePinMetadata()` from `../../src/lib/openai/client` (adjust import path for server context)
     - Insert generation history
     - Update pin with metadata + status 'metadaten_erstellt'
     - On per-pin error: update that pin's status to 'fehler' with error_message, continue to next pin
   - Return summary: `{ pins_processed, pins_succeeded, pins_failed }`

3. Update `server/inngest/index.ts`:
   - Import `generateMetadataBulk` from './functions/generate-metadata'
   - Add to exports and `functions` array
  </action>
  <verify>
Run `npm run build` — no TypeScript errors. Verify `server/inngest/index.ts` exports the new function. Check that `src/lib/server/metadata.ts` exports all three server functions.
  </verify>
  <done>Server functions for single/feedback/bulk metadata generation implemented. Inngest pipeline handles bulk processing with per-pin retry. Status auto-advances to metadaten_erstellt on success, fehler on error.</done>
</task>

<task type="auto">
  <name>Task 2: Client API layer and TanStack Query hooks for metadata</name>
  <files>
    src/lib/api/metadata.ts
    src/lib/hooks/use-metadata.ts
  </files>
  <action>
1. Create `src/lib/api/metadata.ts`:
   - Import supabase from '@/lib/supabase'
   - Import PinMetadataGeneration from '@/types/pins'

   a) `getMetadataHistory(pinId: string): Promise<PinMetadataGeneration[]>`:
      - Query `pin_metadata_generations` WHERE pin_id = pinId, ORDER BY created_at DESC, LIMIT 3
      - Return array of generations

   b) `restoreMetadataGeneration(pinId: string, generationId: string): Promise<void>`:
      - Fetch the generation by id from `pin_metadata_generations`
      - Update `pins` table: set title, description, alt_text from the selected generation

2. Create `src/lib/hooks/use-metadata.ts`:
   - Import useQuery, useMutation, useQueryClient from '@tanstack/react-query'
   - Import toast from 'sonner'
   - Import server functions from '@/lib/server/metadata'
   - Import API functions from '@/lib/api/metadata'

   a) `useMetadataHistory(pinId: string)`:
      - useQuery with queryKey: ['metadata-history', pinId]
      - queryFn: () => getMetadataHistory(pinId)
      - enabled: !!pinId
      - staleTime: 30000

   b) `useGenerateMetadata()`:
      - useMutation calling `generateMetadataFn({ data: { pin_id } })`
      - onSuccess: toast.success('Metadata generated'), invalidate ['pins'] and ['metadata-history']
      - onError: toast.error('Failed to generate metadata')

   c) `useGenerateMetadataWithFeedback()`:
      - useMutation calling `generateMetadataWithFeedbackFn({ data: { pin_id, feedback } })`
      - onSuccess: toast.success('Metadata regenerated'), invalidate ['pins'] and ['metadata-history']
      - onError: toast.error('Failed to regenerate metadata')

   d) `useTriggerBulkMetadata()`:
      - useMutation calling `triggerBulkMetadataFn({ data: { pin_ids } })`
      - onSuccess: (data) => toast.success(`Metadata generation started for ${data.pins_queued} pins`), invalidate ['pins']
      - onError: toast.error('Failed to start bulk metadata generation')

   e) `useRestoreMetadataGeneration()`:
      - useMutation calling restoreMetadataGeneration(pinId, generationId)
      - onSuccess: toast.success('Metadata restored'), invalidate ['pins'] and ['metadata-history']
      - onError: toast.error('Failed to restore metadata')
  </action>
  <verify>
Run `npm run build` — no TypeScript errors. Check that `src/lib/hooks/use-metadata.ts` exports all five hooks. Check that `src/lib/api/metadata.ts` exports both API functions.
  </verify>
  <done>Complete client data layer for metadata operations. Hooks ready for UI consumption in Plans 03-05.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. Server functions authenticate via cookies and resolve tenant_id
3. Single metadata generation calls OpenAI and stores history
4. Feedback regeneration builds conversation messages with previous generation
5. Bulk generation sends Inngest event
6. Inngest function processes pins sequentially with per-pin error handling
7. Client hooks expose all metadata operations with toast feedback
</verification>

<success_criteria>
- Single pin metadata generation works end-to-end (server function -> OpenAI -> store history -> update pin)
- Bulk metadata generation dispatches to Inngest
- Regeneration with feedback includes previous generation in conversation
- Generation history is queryable per pin (last 3)
- All hooks export correctly for UI consumption
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-metadata-publishing/05-02-SUMMARY.md`
</output>
