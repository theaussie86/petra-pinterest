---
phase: 05-ai-metadata-publishing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00006_metadata_generation.sql
  - src/lib/openai/client.ts
  - src/lib/openai/prompts.ts
  - src/types/pins.ts
  - .env.example
autonomous: true
user_setup:
  - service: openai
    why: "AI metadata generation via GPT-4o with vision"
    env_vars:
      - name: OPENAI_API_KEY
        source: "OpenAI Dashboard -> API keys -> Create new secret key"

must_haves:
  truths:
    - "pin_metadata_generations table exists with RLS policies"
    - "pins table has alt_text and previous_status columns"
    - "OpenAI client is configured and exportable"
    - "Pinterest SEO system prompt is defined with character limits"
  artifacts:
    - path: "supabase/migrations/00006_metadata_generation.sql"
      provides: "Schema additions for metadata generation"
      contains: "pin_metadata_generations"
    - path: "src/lib/openai/client.ts"
      provides: "OpenAI client singleton"
      exports: ["openai"]
    - path: "src/lib/openai/prompts.ts"
      provides: "Pinterest SEO system prompt"
      exports: ["PINTEREST_SEO_SYSTEM_PROMPT"]
    - path: "src/types/pins.ts"
      provides: "Updated Pin type with alt_text"
      contains: "alt_text"
  key_links:
    - from: "src/lib/openai/client.ts"
      to: "OPENAI_API_KEY env var"
      via: "process.env.OPENAI_API_KEY"
      pattern: "process\\.env\\.OPENAI_API_KEY"
---

<objective>
Set up the database schema, OpenAI client, and Pinterest SEO prompts for AI metadata generation.

Purpose: Foundation layer that all subsequent plans depend on — database tables, AI client, and prompt definitions.
Output: Migration file, OpenAI client module, prompt constants, updated Pin type with alt_text.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-metadata-publishing/05-CONTEXT.md
@.planning/phases/05-ai-metadata-publishing/05-RESEARCH.md
@src/types/pins.ts
@supabase/migrations/00005_pins_and_boards.sql
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration for metadata generation</name>
  <files>supabase/migrations/00006_metadata_generation.sql</files>
  <action>
Create migration 00006_metadata_generation.sql with:

1. Add `alt_text` column to `pins` table (text, nullable).
2. Add `previous_status` column to `pins` table (pin_status enum, nullable) — tracks the status before the current one for error recovery "Reset to previous state".
3. Create `pin_metadata_generations` table:
   - `id` uuid primary key default gen_random_uuid()
   - `pin_id` uuid NOT NULL references pins(id) ON DELETE CASCADE
   - `tenant_id` uuid NOT NULL
   - `title` text NOT NULL
   - `description` text NOT NULL
   - `alt_text` text NOT NULL
   - `feedback` text (nullable — null for first generation, text for regenerations)
   - `created_at` timestamptz NOT NULL default now()
   - Index on (pin_id, created_at DESC) for fast history lookups
   - No unique constraint on (pin_id, created_at) — multiple generations at different times is fine

4. Enable RLS on `pin_metadata_generations`:
   - SELECT policy: `tenant_id IN (SELECT tenant_id FROM profiles WHERE id = auth.uid())`
   - INSERT policy: same tenant check
   - DELETE policy: same tenant check (for pruning old generations)

5. Create a trigger function `update_previous_status()` on `pins` table: before UPDATE on status column, set `previous_status = OLD.status` when `NEW.status != OLD.status`. Attach trigger `trg_update_previous_status` BEFORE UPDATE ON pins.

Apply via Supabase MCP `apply_migration`.
  </action>
  <verify>
Run via Supabase MCP: `SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'pin_metadata_generations' ORDER BY ordinal_position;` — returns id, pin_id, tenant_id, title, description, alt_text, feedback, created_at columns.

Also verify: `SELECT column_name FROM information_schema.columns WHERE table_name = 'pins' AND column_name IN ('alt_text', 'previous_status');` — returns both columns.
  </verify>
  <done>pin_metadata_generations table exists with RLS. pins table has alt_text and previous_status columns. Trigger tracks previous_status on status changes.</done>
</task>

<task type="auto">
  <name>Task 2: OpenAI client, prompts, and type updates</name>
  <files>
    src/lib/openai/client.ts
    src/lib/openai/prompts.ts
    src/types/pins.ts
    .env.example
  </files>
  <action>
1. Install openai package: `npm install openai`

2. Create `src/lib/openai/client.ts`:
   - Import OpenAI from 'openai'
   - Export singleton `openai` instance: `new OpenAI({ apiKey: process.env.OPENAI_API_KEY })`
   - Export `generatePinMetadata(articleTitle: string, articleContent: string, pinImageUrl: string, systemPrompt?: string)` async function:
     - Uses `openai.chat.completions.create()` with model 'gpt-4o'
     - Content array with type: "text" (article title + content truncated to 4000 chars) and type: "image_url" (pinImageUrl, detail: "auto")
     - max_tokens: 500, temperature: 0.7
     - Parse JSON response into `{ title: string; description: string; alt_text: string }`
     - Wrap JSON.parse in try/catch — if parsing fails, throw descriptive error
     - systemPrompt parameter defaults to PINTEREST_SEO_SYSTEM_PROMPT from prompts.ts

3. Create `src/lib/openai/prompts.ts`:
   - Export `PINTEREST_SEO_SYSTEM_PROMPT` string constant with the Pinterest SEO prompt from RESEARCH.md:
     - Title: max 100 chars, lead with benefit/outcome, 1-2 keywords
     - Description: first 50 chars critical (preview), 220-232 chars total, include CTA, long-tail keywords
     - Alt text: literal image description, 1-2 keywords, max 125 chars
     - Output format: JSON with title, description, alt_text fields only

4. Update `src/types/pins.ts`:
   - Add `alt_text: string | null` to `Pin` interface (after `description`)
   - Add `previous_status: PinStatus | null` to `Pin` interface (after `error_message`)
   - Add `alt_text?: string | null` to `PinUpdate` interface
   - Add `scheduled_at?: string | null` to `PinUpdate` interface (needed for scheduling in later plans)
   - Export new interface `PinMetadataGeneration`:
     ```
     id: string
     pin_id: string
     tenant_id: string
     title: string
     description: string
     alt_text: string
     feedback: string | null
     created_at: string
     ```

5. Add `OPENAI_API_KEY=your-openai-api-key` to `.env.example` under a new "# OpenAI Configuration" section.
  </action>
  <verify>
Run `npm run build` — no TypeScript errors. Verify `src/lib/openai/client.ts` and `src/lib/openai/prompts.ts` exist and export the expected symbols. Check `src/types/pins.ts` includes alt_text in Pin interface.
  </verify>
  <done>OpenAI client module configured. Pinterest SEO prompt defined. Pin types updated with alt_text, previous_status, PinMetadataGeneration. Environment variable documented.</done>
</task>

</tasks>

<verification>
1. Migration applied: `pin_metadata_generations` table exists with all columns and RLS policies
2. `pins` table has `alt_text` and `previous_status` columns
3. `previous_status` trigger fires on status changes
4. `npm run build` passes with updated types
5. OpenAI client and prompts modules exist and export correctly
</verification>

<success_criteria>
- Database schema supports metadata generation history storage
- OpenAI client is ready for use by server functions (Plan 02)
- Pinterest SEO prompt encodes character limits and formatting rules
- Pin type includes alt_text for metadata and previous_status for error recovery
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-metadata-publishing/05-01-SUMMARY.md`
</output>
