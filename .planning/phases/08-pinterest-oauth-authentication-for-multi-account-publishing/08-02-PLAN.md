---
phase: 08-pinterest-oauth
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/lib/server/pinterest-oauth.ts
  - src/routes/auth/pinterest.callback.tsx
autonomous: true

must_haves:
  truths:
    - "User can initiate Pinterest OAuth from a blog project context"
    - "OAuth callback exchanges code for tokens and stores them encrypted in Vault"
    - "User is redirected back to the project page after successful OAuth"
    - "OAuth failure redirects user back to project with error indication"
    - "User can disconnect a Pinterest account from a blog project"
  artifacts:
    - path: "src/lib/server/pinterest-oauth.ts"
      provides: "Server functions for OAuth initiation, token exchange, and disconnect"
      exports: ["initPinterestOAuthFn", "exchangePinterestCallbackFn", "disconnectPinterestFn", "getPinterestConnectionFn"]
    - path: "src/routes/auth/pinterest.callback.tsx"
      provides: "OAuth redirect handler route"
      contains: "createFileRoute"
  key_links:
    - from: "src/lib/server/pinterest-oauth.ts"
      to: "src/lib/server/pinterest-api.ts"
      via: "import exchangePinterestCode, fetchPinterestUser, generateCodeVerifier, generateCodeChallenge, generateState"
      pattern: "import.*pinterest-api"
    - from: "src/routes/auth/pinterest.callback.tsx"
      to: "src/lib/server/pinterest-oauth.ts"
      via: "import exchangePinterestCallbackFn"
      pattern: "import.*pinterest-oauth"
    - from: "src/lib/server/pinterest-oauth.ts"
      to: "supabase vault.secrets"
      via: "store_pinterest_tokens RPC"
      pattern: "store_pinterest_tokens"
---

<objective>
Implement the complete Pinterest OAuth 2.0 flow with PKCE + state parameter security.

Purpose: This is the core authentication mechanism that enables all Pinterest API operations. Users must be able to connect their Pinterest account to a blog project, and tokens must be securely stored for subsequent API calls (board syncing, publishing).

Output: Server functions for OAuth initiation/exchange/disconnect, OAuth callback route handler, and a server function to fetch connection status.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-pinterest-oauth-authentication-for-multi-account-publishing/08-CONTEXT.md
@.planning/phases/08-pinterest-oauth-authentication-for-multi-account-publishing/08-RESEARCH.md
@.planning/phases/08-pinterest-oauth-authentication-for-multi-account-publishing/08-01-SUMMARY.md
@src/lib/server/auth.ts
@src/lib/server/supabase.ts
@src/lib/server/pinterest-api.ts
@src/types/pinterest.ts
@src/routes/auth.callback.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pinterest OAuth server functions</name>
  <files>src/lib/server/pinterest-oauth.ts</files>
  <action>
Create `src/lib/server/pinterest-oauth.ts` with four server functions using `createServerFn` from `@tanstack/react-start`. All functions authenticate the user via `getSupabaseServerClient()` and `supabase.auth.getUser()` before proceeding.

**1. `initPinterestOAuthFn`** (method: 'POST', input: `{ blog_project_id: string }`):
- Authenticate user, get tenant_id from profiles table
- Verify blog_project_id belongs to user's tenant (SELECT from blog_projects with tenant_id check)
- Generate PKCE code_verifier and code_challenge using helpers from pinterest-api.ts
- Generate random state parameter
- Store state mapping in oauth_state_mapping table: { state, code_verifier, blog_project_id, tenant_id, user_id }
- Build Pinterest OAuth authorization URL:
  - Base: `https://www.pinterest.com/oauth/`
  - Params: client_id (PINTEREST_APP_ID env), redirect_uri (PINTEREST_REDIRECT_URI env), response_type=code, scope=`boards:read,boards:write,pins:read,pins:write`, state, code_challenge, code_challenge_method=S256
- Return `{ authUrl: string }`

**2. `exchangePinterestCallbackFn`** (method: 'POST', input: `{ code: string, state: string }`):
- Look up state in oauth_state_mapping table
- Verify state exists and hasn't expired (created_at + 10 min > now)
- If invalid/expired, return `{ success: false, error: 'Invalid or expired state' }`
- Call `exchangePinterestCode(code, stateRow.code_verifier)` from pinterest-api.ts
- Call `fetchPinterestUser(tokens.access_token)` to get Pinterest username
- Check if pinterest_connection already exists for this (tenant_id, pinterest_user_id) — if so, update it and update tokens
- If new: INSERT into pinterest_connections with pinterest_user_id (from user response), pinterest_username, scope (from token response), token_expires_at (now + expires_in seconds), is_active=true
- Store tokens in Vault via `store_pinterest_tokens` RPC (pass connection_id, access_token, refresh_token)
- Update blog_projects.pinterest_connection_id to point to this connection
- Delete the oauth_state_mapping row (cleanup)
- Return `{ success: true, blog_project_id: stateRow.blog_project_id, pinterest_username: user.username }`
- On any error: delete state mapping, return `{ success: false, error: message }`

Note: Use `getSupabaseServiceClient()` (service role) for Vault operations since authenticated client can't access vault.secrets directly. Use authenticated client for user verification and state mapping lookup.

**3. `disconnectPinterestFn`** (method: 'POST', input: `{ blog_project_id: string }`):
- Authenticate user, get tenant_id
- Fetch blog_project to get pinterest_connection_id, verify tenant ownership
- If no connection, return `{ success: true }` (already disconnected)
- Set blog_projects.pinterest_connection_id to null
- Check if any OTHER blog_projects still reference this connection_id
- If no other projects use it: delete tokens from Vault via `delete_pinterest_tokens` RPC, delete the pinterest_connections row
- If other projects still use it: only null out this project's FK (don't delete connection)
- Return `{ success: true }`

**4. `getPinterestConnectionFn`** (method: 'GET', input: `{ blog_project_id: string }`):
- Authenticate user
- Fetch blog_project with pinterest_connection_id, verify tenant ownership
- If no pinterest_connection_id, return `{ connected: false }`
- Fetch the pinterest_connections row by id
- Return `{ connected: true, connection: { id, pinterest_username, is_active, last_error, token_expires_at } }`

Error handling pattern: wrap all handlers in try/catch, return structured `{ success: false, error: string }` on failure.
  </action>
  <verify>`npm run build` succeeds. Verify all four server functions are exported. Check that imports from pinterest-api.ts resolve correctly.</verify>
  <done>Four server functions exported: initPinterestOAuthFn, exchangePinterestCallbackFn, disconnectPinterestFn, getPinterestConnectionFn. All use proper authentication, Vault for token storage, and structured error responses.</done>
</task>

<task type="auto">
  <name>Task 2: Pinterest OAuth callback route</name>
  <files>src/routes/auth/pinterest.callback.tsx</files>
  <action>
Create `src/routes/auth/pinterest.callback.tsx` — a TanStack Router file-based route at `/auth/pinterest/callback`.

This route handles the redirect from Pinterest after the user authorizes (or denies) the app.

**Route definition:**
- `createFileRoute('/auth/pinterest/callback')`
- `validateSearch`: extract `code`, `state`, `error` from search params (all optional strings)
- `beforeLoad`: async handler that processes the OAuth callback

**beforeLoad logic:**

1. If `search.error` exists (user cancelled or Pinterest error):
   - Look up state mapping to get blog_project_id (if state param exists)
   - Redirect to `/projects/$id` with `search: { pinterest_error: search.error }` if blog_project_id found
   - Otherwise redirect to `/dashboard` with error

2. If `search.code` and `search.state` exist (successful authorization):
   - Call `exchangePinterestCallbackFn({ data: { code: search.code, state: search.state } })`
   - If result.success: redirect to `/projects/$id` with `params: { id: result.blog_project_id }` and `search: { pinterest_connected: 'true' }`
   - If !result.success: redirect to `/projects/$id` (if blog_project_id available from state lookup) or `/dashboard` with `search: { pinterest_error: result.error }`

3. If neither code nor error: redirect to `/dashboard`

Use `throw redirect(...)` for all redirects (TanStack Router pattern matching existing auth.callback.tsx).

**Component:** Simple loading spinner fallback (same pattern as existing `auth.callback.tsx`):
```tsx
function PinterestCallbackFallback() {
  return (
    <div className="flex min-h-screen items-center justify-center bg-slate-50">
      <div className="text-center">
        <div className="mb-4 h-12 w-12 animate-spin rounded-full border-4 border-slate-300 border-t-slate-900 mx-auto" />
        <p className="text-lg text-slate-600">Connecting Pinterest...</p>
      </div>
    </div>
  )
}
```

Import `exchangePinterestCallbackFn` from `@/lib/server/pinterest-oauth`.

Note: The `/auth/pinterest/callback` path creates a nested route structure. TanStack Router file-based routing uses the folder `auth/` with file `pinterest.callback.tsx` — verify the route tree generates correctly by checking `routeTree.gen.ts` after dev server runs. The existing auth.callback.tsx uses dot notation (`auth.callback.tsx` = `/auth/callback`), so follow the same: `auth.pinterest.callback.tsx` would be at `src/routes/auth.pinterest.callback.tsx` (NOT nested folder). Actually, looking at the existing pattern, the file should be `src/routes/auth.pinterest.callback.tsx` for route `/auth/pinterest/callback`. TanStack Router uses dots for path separators in file-based routing.

Correct file path: `src/routes/auth.pinterest.callback.tsx`
  </action>
  <verify>Run `npm run dev` briefly to confirm route tree generates. Check that `src/routeTree.gen.ts` includes the `/auth/pinterest/callback` route. `npm run build` succeeds.</verify>
  <done>Pinterest OAuth callback route exists at `/auth/pinterest/callback`, handles success (token exchange + redirect to project) and failure (redirect with error), matches existing auth callback pattern.</done>
</task>

</tasks>

<verification>
- `src/lib/server/pinterest-oauth.ts` exports 4 server functions
- `src/routes/auth.pinterest.callback.tsx` exists and handles OAuth redirect
- OAuth flow: initiate -> Pinterest authorize -> callback -> token exchange -> redirect
- Build passes with no TypeScript errors
</verification>

<success_criteria>
Complete OAuth 2.0 flow with PKCE + state parameter security. Users can initiate OAuth from project context, complete authorization on Pinterest, return to the app with tokens stored in Vault, and have their blog project linked to the Pinterest connection. Disconnect capability removes the link and cleans up tokens when no other projects reference the connection.
</success_criteria>

<output>
After completion, create `.planning/phases/08-pinterest-oauth-authentication-for-multi-account-publishing/08-02-SUMMARY.md`
</output>
